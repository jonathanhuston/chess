global white, black, empty

global a, b, c, d, e, f, g, h

global king, queen, rook, knight, bishop, pawn

global human, computer

record position (file, rank)

record squarecontent (squarecolor, squarepiece)

record flagrecord (cancastle, enpassant, draw, promotion, origin, dest, counter)

link brainless


procedure initializeconstants ();
	white := 1;
	black := 2;
	empty := 0;

	a := 1;
	b := 2;
	c := 3;
	d := 4;
	e := 5;
	f := 6;
	g := 7;
	h := 8;

	king := 1;
	queen := 2;
	rook := 3;
	knight := 4;
	bishop := 5;
	pawn := 6;

	human := 1;
	computer := 2;
end


procedure initializepieces (pieces);
	local x;

	every !pieces := [set (), set ()];

	insert (pieces [king] [white], position (e, 1));
	insert (pieces [king] [black], position (e, 8));

	insert (pieces [queen] [white], position (d, 1));
	insert (pieces [queen] [black], position (d, 8));

	insert (pieces [rook] [white], position (a, 1));
	insert (pieces [rook] [black], position (a, 8));
	insert (pieces [rook] [white], position (h, 1));
	insert (pieces [rook] [black], position (h, 8));

	insert (pieces [knight] [white], position (b, 1));
	insert (pieces [knight] [black], position (b, 8));
	insert (pieces [knight] [white], position (g, 1));
	insert (pieces [knight] [black], position (g, 8));

	insert (pieces [bishop] [white], position (c, 1));
	insert (pieces [bishop] [black], position (c, 8));
	insert (pieces [bishop] [white], position (f, 1));
	insert (pieces [bishop] [black], position (f, 8));
	
	every x := a to h do {
		insert (pieces [pawn] [white], position (x, 2));
		insert (pieces [pawn] [black], position (x, 7));
	};
end


procedure initializeboard (board, pieces);
	local piece, color, square;

	every !board := list (8, squarecontent (0, 0));	
	every color := white to black &
		every piece := king to pawn &
			every square := !pieces [piece] [color] &
				board [square.file] [square.rank] := squarecontent (color, piece);
end


procedure initializeflags (flags);
	flags.cancastle := list (2, a+h);
	flags.enpassant := position (empty, empty);
	flags.draw := 0;
	flags.promotion := "Q";
	flags.origin := position (empty, empty);
	flags.dest := position (empty, empty);
	flags.counter := 1;
end



procedure displaysquare (square);
	writes (char (ord ("a") + square.file - 1), square.rank);
end


procedure displaypiece (color, piece);
	if color = white then		case piece of {
			king : writes ("K");
			queen : writes ("Q");
			rook : writes ("R");
			knight : writes ("N");
			bishop : writes ("B");
			pawn : writes ("P")
		} 
	else if color = black then
		case piece of {
			king : writes ("k");
			queen : writes ("q");
			rook : writes ("r");
			knight : writes ("n");
			bishop : writes ("b");
			pawn : writes ("p")
		}
	else
		writes (".");
end


procedure displaymove (origin, dest);
	displaysquare (origin);
	displaysquare (dest);
end


procedure displayboard (board);
	write ();

	every y := 8 to 1 by -1 do {
		writes (y, " ");
		every x := 1 to 8 do
			displaypiece ((board [x][y]).squarecolor, (board [x][y]).squarepiece);
		write ();
	};
	write ();
	writes ("  ");
	every x := 1 to 8 do
		writes (char (ord ("a") + x - 1));
	write ();
	write ();
end


procedure othercolor (color);
	return 3 - color;
end


procedure otherplayer (currentplayer);
	return 3 - currentplayer;
end


procedure samesquare (s1, s2);
	return (s1.file = s2.file & s1.rank = s2.rank);
end


procedure copysquare (s1, s2);
	s2.file := s1.file;
	s2.rank := s1.rank;
end


procedure removesquare (positions, square);
	local tempsquare;

	every tempsquare := !positions do
		if tempsquare.file = square.file & tempsquare.rank = square.rank then
			delete (positions, tempsquare);
end


procedure issquare (positions, square);
	local tempsquare;

	every tempsquare := !positions do
		if tempsquare.file = square.file & tempsquare.rank = square.rank then
			return;
	fail;
end


procedure copyboard (board, pieces, flags, boardcopy, piecescopy, flagscopy);
	local x, y, piece, color, square;

	every x := a to h &
		every y := 1 to 8 do
			boardcopy [x] [y] := copy (board [x] [y]);

	every color := white to black &
		every piece := king to pawn do
			piecescopy [piece] [color] := copy (pieces [piece] [color]);

	flagscopy.cancastle := copy (flags.cancastle);
	flagscopy.enpassant := copy (flags.enpassant);
	flagscopy.draw := flags.draw;
	flagscopy.promotion := flags.promotion;
end


procedure movepiece (board, pieces, flags, color, origin, dest);
	local piece, newpiece, positions;

	piece := (board [origin.file] [origin.rank]).squarepiece;

	if piece = pawn & dest.rank = (1 | 8) then
		case flags.promotion of {
			"Q": newpiece := queen;
			"R" : newpiece := rook;
			"N" : newpiece := knight;
			"B" : newpiece := bishop
		}
	else 
		newpiece := piece;

	removesquare (pieces [piece] [color], origin);
	insert (pieces [newpiece] [color], dest);


	if (board [dest.file] [dest.rank]).squarecolor = othercolor (color) then {
		piece := (board [dest.file] [dest.rank]).squarepiece;
		removesquare (pieces [piece, othercolor (color)], dest);
		flags.draw := 0;
	};

	board [origin.file] [origin.rank] := squarecontent (empty, empty);
	board [dest.file] [dest.rank] := squarecontent (color, newpiece);

	if piece = king & abs (dest.file - origin.file) = 2 then
		if dest.file = g then {
			removesquare (pieces [rook] [color], position (h, color^3));
			insert (pieces [rook] [color], position (f, color^3));
			board [h] [color^3] := squarecontent (empty, empty);
			board [f] [color^3] := squarecontent (color, rook);
		} else {
			removesquare (pieces [rook] [color], position (a, color^3));
			insert (pieces [rook] [color], position (d, color^3));
			board [a] [color^3] := squarecontent (empty, empty);
			board [d] [color^3] := squarecontent (color, rook);
		};

	if flags.cancastle [color] > 0 then {
		if piece = king then 
			flags.cancastle [color] := 0
		else if piece = rook then
			if flags.cancastle [color] = (a | a+h) &  
				samesquare (origin, position (a, color^3)) then
					flags.cancastle [color] := flags.cancastle [color] - a
			else if flags.cancastle [color] = (h | a+h) & 
				samesquare (origin, position (h, color^3)) then
					flags.cancastle [color] := flags.cancastle [color] - h;
	};

	if piece = pawn & samesquare (dest, flags.enpassant) then {
		removesquare (pieces [pawn] [othercolor (color)], 
			position (dest.file, othercolor (color)+3));
		board [dest.file] [othercolor (color)+3] := squarecontent (empty, empty);
	};

	if piece = pawn & abs (dest.rank - origin.rank) = 2 then
		flags.enpassant := position (dest.file, color*3)
	else
		flags.enpassant := position (empty, empty); 

	if piece = pawn then flags.draw := 0 else flags.draw +:= 1;
end


procedure ischeck (board, pieces, flags, color, check);
	local moves, kingpos;

	if \check then {		kingpos := ? pieces [king] [color];
		moves := set ();
		generateall (board, pieces, flags, othercolor (color), moves, &null);
		return (issquare (moves, kingpos));
	} else fail;
end


procedure testmove (board, pieces, flags, color, origin, x, y, moves, check);
	local boardcopy, piecescopy, flagscopy;

	if (board [x] [y]).squarecolor = color then fail;

	boardcopy := list (8);
	every !boardcopy := list (8, squarecontent (0, 0));
	piecescopy := list (6);
	every !piecescopy := [set (), set ()];
	flagscopy := flagrecord ();
	copyboard (board, pieces, flags, boardcopy, piecescopy, flagscopy);

	movepiece (boardcopy, piecescopy, flagscopy, color, origin, position (x, y));
	if not (ischeck (boardcopy, piecescopy, flagscopy, color, check)) then 
		insert (moves, position (x, y));

	if (board [x] [y]).squarecolor = othercolor (color) then fail;
	return;
end


procedure generateking (board, pieces, flags, color, origin, moves, check);
	local x, y, cancastle;

	every x := origin.file - 1 to origin.file + 1 & (a <= x <= h) &
		every y := origin.rank - 1 to origin.rank + 1 & (1 <= y <= 8) do
			testmove (board, pieces, flags, color, origin, x, y, moves, check);

	cancastle := flags.cancastle [color];

	if cancastle > 0 & not (ischeck (board, pieces, flags, color, check)) then {
		if cancastle = (h | a+h) &
			(board [f] [color^3]).squarecolor = empty &
			(board [g] [color^3]).squarecolor = empty &
			(board [h] [color^3]).squarecolor = color &
			(board [h] [color^3]).squarepiece = rook then {
				movepiece (board, pieces, flags, color, origin, position (f, color^3));
				if not (ischeck (board, pieces, flags, color, check)) then
					testmove (board, pieces, flags, color, position (f, color^3), g, color^3, moves, check);
				movepiece (board, pieces, flags, color, position (f, color^3), origin);
		} else if cancastle = (a | a+h) &
			(board [d] [color^3]).squarecolor = empty &
			(board [c] [color^3]).squarecolor = empty &
			(board [b] [color^3]).squarecolor = empty &
			(board [a] [color^3]).squarecolor = color &
			(board [a] [color^3]).squarepiece = rook then {
				movepiece (board, pieces, flags, color, origin, position (d, color^3));
				if not (ischeck (board, pieces, flags, color, check)) then
					testmove (board, pieces, flags, color, position (d, color^3), c, color^3, moves, check);
				movepiece (board, pieces, flags, color, position (d, color^3), origin);
		};
	};		

	flags.cancastle [color] := cancastle;

end


procedure generaterook (board, pieces, flags, color, origin, moves, check);
	local x, y;

	every x := origin.file + 1 to h do
		if not (testmove (board, pieces, flags, color, origin, x, origin.rank, moves, check)) then break;

	every x := origin.file - 1 to a by -1 do
		if not (testmove (board, pieces, flags, color, origin, x, origin.rank, moves, check)) then break;

	every y := origin.rank + 1 to 8 do
		if not (testmove (board, pieces, flags, color, origin, origin.file, y, moves, check)) then break;

	every y := origin.rank - 1 to 1 by -1 do
		if not (testmove (board, pieces, flags, color, origin, origin.file, y, moves, check)) then break;
end


procedure generatebishop (board, pieces, flags, color, origin, moves, check);
	local d;

	every d := 1 to 7 & origin.file + d <= h & origin.rank + d <= 8 do 
		if not (testmove (board, pieces, flags, color, origin, origin.file + d, origin.rank + d, moves, check)) then break;

	every d := 1 to 7 & origin.file + d <= h & origin.rank - d >= 1 do 
		if not (testmove (board, pieces, flags, color, origin, origin.file + d, origin.rank - d, moves, check)) then break;

	every d := 1 to 7 & origin.file - d >= a & origin.rank + d <= 8 do 
		if not (testmove (board, pieces, flags, color, origin, origin.file - d, origin.rank + d, moves, check)) then break;

	every d := 1 to 7 & origin.file - d >= a & origin.rank - d >= 1 do 
		if not (testmove (board, pieces, flags, color, origin, origin.file - d, origin.rank - d, moves, check)) then break;
end


procedure generatequeen (board, pieces, flags, color, origin, moves, check);
	generaterook (board, pieces, flags, color, origin, moves, check);
	generatebishop (board, pieces, flags, color, origin, moves, check);
end


procedure generateknight (board, pieces, flags, color, origin, moves, check);
	local dx, dy;

	every dx := (-2 | -1 | 1 | 2) & every dy := (-2 | -1 | 1 | 2) &
		abs (dx) + abs (dy) = 3 & 
			a <= origin.file + dx <= h & 1 <= origin.rank + dy <= 8 do
				testmove (board, pieces, flags, color, origin, origin.file+dx, origin.rank+dy, moves, check);
end


procedure generatepawn (board, pieces, flags, color, origin, moves, check);
	if color = white then {
		if (board [origin.file] [origin.rank + 1]).squarecolor = empty & \check then {
			testmove (board, pieces, flags, white, origin, origin.file, origin.rank + 1, moves, check);
			if origin.rank = 2 & (board [origin.file] [4]).squarecolor = empty then
				testmove (board, pieces, flags, white, origin, origin.file, 4, moves, check);
		};
		if origin.file >= b & 
			((board [origin.file - 1] [origin.rank + 1]).squarecolor = black |
			samesquare (flags.enpassant, position (origin.file - 1, origin.rank + 1))) then
				testmove (board, pieces, flags, white, origin, origin.file - 1, origin.rank + 1, moves, check);
		if origin.file <= h &
			((board [origin.file + 1] [origin.rank + 1]).squarecolor = black |
			samesquare (flags.enpassant, position (origin.file + 1, origin.rank + 1))) then
				testmove (board, pieces, flags, white, origin, origin.file + 1, origin.rank + 1, moves, check);
	} else {
		if (board [origin.file] [origin.rank - 1]).squarecolor = empty & \check then {
			testmove (board, pieces, flags, black, origin, origin.file, origin.rank - 1, moves, check);
			if origin.rank = 7 & (board [origin.file] [5]).squarecolor = empty then 
				testmove (board, pieces, flags, black, origin, origin.file, 5, moves, check);
		};
		if origin.file >= b & 
			((board [origin.file - 1] [origin.rank - 1]).squarecolor = white |
			samesquare (flags.enpassant, position (origin.file - 1, origin.rank - 1))) then
				testmove (board, pieces, flags, black, origin, origin.file - 1, origin.rank - 1, moves, check);
		if origin.file <= h &
			((board [origin.file + 1] [origin.rank - 1]).squarecolor = white |
			samesquare (flags.enpassant, position (origin.file + 1, origin.rank - 1))) then
				testmove (board, pieces, flags, black, origin, origin.file + 1, origin.rank - 1, moves, check);
	};
end


procedure generatemoves (board, pieces, flags, color, origin, moves, check);
	case (board [origin.file] [origin.rank]).squarepiece of {
		king : generateking (board, pieces, flags, color, origin, moves, check);
		queen : generatequeen (board, pieces, flags, color, origin, moves, check);
		rook : generaterook (board, pieces, flags, color, origin, moves, check);
		knight : generateknight (board, pieces, flags, color, origin, moves, check);
		bishop : generatebishop (board, pieces, flags, color, origin, moves, check);
		pawn : generatepawn (board, pieces, flags, color, origin, moves, check)
	};
end


procedure generateall (board, pieces, flags, color, moves, check);
	local piece, square, piecemoves, squarelist;
	
	every piece := king to pawn do {
		squarelist := sort (pieces [piece][color]);
		every square := !squarelist do {
			piecemoves := set ();
			generatemoves (board, pieces, flags, color, square, piecemoves, check);
			every insert (moves, copy (!piecemoves));
		};
	};
end


procedure nomoves (board, pieces, flags, color);
	local moves;
	
	moves := set ();
	generateall (board, pieces, flags, color, moves, king);
	return (*moves = 0);
end


procedure ismate (board, pieces, flags, color);
	return (ischeck (board, pieces, flags, color, king) & nomoves (board, pieces, flags, color));
end


procedure isdraw (flags);
	return (flags.draw >= 100);
end
	

procedure islegalmove (board, pieces, flags, color, origin, dest);
	local move, moves;

	if (board [origin.file] [origin.rank]).squarecolor ~= color | 
	(board [dest.file] [dest.rank]).squarecolor = color then
		fail
	else {
		moves := set ();
		generatemoves (board, pieces, flags, color, origin, moves, king);
		every move := !moves do
			if samesquare (move, dest) then return;
		fail;		
	};
end


procedure isvalidentry (board, inputmove);
	if not (4 <= *inputmove <= 5) then fail;

	if not (ord ("a") <= ord (inputmove [1]) <= ord ("h")) then fail;

	if not (ord ("1") <= ord (inputmove [2]) <= ord ("8")) then fail;

	if not (ord ("a") <= ord (inputmove [3]) <= ord ("h")) then fail;

	if not (ord ("1") <= ord (inputmove [4]) <= ord ("8")) then fail;

	if *inputmove = 5 then {
		if not (inputmove [5] == "Q" | "R" | "N" | "B") then fail;
		if inputmove [4] ~== "8" then fail;
	};

	return;
end


procedure gethumanmove (board, pieces, flags, color);
	local inputmove, origin, dest;

	repeat {
		writes (flags.counter, ". ");
		if color = black then {
			displaymove (flags.origin, flags.dest);
			writes (" ");
		};

		inputmove := read ();

		if inputmove == "draw" then break;

		if not (isvalidentry (board, inputmove)) then {
			write ("Invalid entry.");
			next;
		};

		origin := position (ord (inputmove [1]) - ord ("a") + 1, 
					numeric (inputmove [2]));
		dest := position (ord (inputmove [3]) - ord ("a") + 1,
					numeric (inputmove [4]));
		if islegalmove (board, pieces, flags, color, origin, dest) then break;
		write ("Illegal move.");
	};

	if *inputmove = 5 then flags.promotion := inputmove [5];

	if inputmove == "draw" then 
		flags.draw := 100
	else {
		movepiece (board, pieces, flags, color, origin, dest);
		copysquare (origin, flags.origin);
		copysquare (dest, flags.dest);
	};
end


procedure traincomputer (games);
local pieces, board, flags;
local gamecounter, color;

	gamecounter := 1;

	until gamecounter > games do {
		write ("Game: ", gamecounter);
		write ();

		pieces := list (6);
		initializepieces (pieces);

		board := list (8);
		initializeboard (board, pieces);

		flags := flagrecord ();
		initializeflags (flags);

		color := white;

		until nomoves (board, pieces, flags, color) | isdraw (flags) do {
			if color = white then {
				writes (flags.counter, ". ");
			} else
				writes (" ");

			getcomputermove (board, pieces, flags, color);
			displaymove (flags.origin, flags.dest);

			if color = black then {
				flags.counter +:= 1;
				write ();
				displayboard (board);
			};

			color := othercolor (color);
			flags.promotion := "Q";
		};


		if color = black then {
			write ();
			displayboard (board);
		};
		gamecounter +:= 1;
	};
end


procedure playgame (firstplayer);
local pieces, board, flags;
local playercolor, player;

	pieces := list (6);
	initializepieces (pieces);
	
	board := list (8);
	initializeboard (board, pieces);

	flags := flagrecord ();
	initializeflags (flags);

	playercolor := list (2);

	playercolor [firstplayer] := white;
	playercolor [otherplayer (firstplayer)] := black;
	player := firstplayer;

	until nomoves (board, pieces, flags, playercolor [player]) | isdraw (flags) do {
		displayboard (board);
		if player = human then
			gethumanmove (board, pieces, flags, playercolor [human])
		else {
			writes (flags.counter, ". ");
			if playercolor [computer] = black then {
				displaymove (flags.origin, flags.dest);
				writes (" ");
			};
			getcomputermove (board, pieces, flags, playercolor [computer]);
			displaymove (flags.origin, flags.dest);
			write ();
		};
		if playercolor [player] = black then flags.counter +:= 1;
		player := otherplayer (player);
		flags.promotion := "Q";
	};

	displayboard (board);
	if ismate (board, pieces, flags, playercolor [player]) then
		case player of {
			human : write ("You are checkmate.");	computer : write ("I am checkmate.")
		}
	else if isdraw (flags) then
		write ("Draw.")
	else
		write ("Stalemate.");
	write ();
end


procedure main (args);
	initializeconstants ();

	if *args = 0 then
		playgame (human)
	else if args [1] == "-b" then
		playgame (computer)
	else if args [1] == "-c" & \args [2] then
		traincomputer (numeric (args [2]))
	else 
		write ("Invalid arguments.");
end

